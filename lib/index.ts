import envPaths from 'env-paths';
import fs from 'fs/promises';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';

interface HeartbeatInfo {
    heartbeat: string;
}

interface HeartbeatCheck {
    heartbeat: string;
    timestamp: number;
}

/** Path to the data directory where we store heartbeat info */
const dataPath = envPaths('app-container', {
    suffix: '',
}).data;

/** File stores the latest random value generated by the app. */
const heartbeatFilePath = path.join(dataPath, 'heartbeat.json');

/** File stores the app-generated value last-seen by the healthcheck process. */
const lastSeenFilePath = path.join(dataPath, 'heartbeat-check.json');

/** Used to avoid concurrent heartbeats. */
let currentHeartbeat: Promise<void> | undefined;

/**
 * Signal heartbeat to the healthcheck process.
 * Signaling is done by generating a new random heartbeat value.
 */
export async function signalHeartbeat(): Promise<void> {
    if (currentHeartbeat != null) {
        return currentHeartbeat;
    }

    currentHeartbeat = setCurrentHeartbeat();

    try {
        await currentHeartbeat;
    } finally {
        currentHeartbeat = undefined;
    }
}

/**
 * Checks if the task is healthy.
 * 
 * A task is healthy if the observed heartbeat value is new, or the value is stale but for at most `staleInterval` milliseconds.
 * 
 * Usage:
 * `healthcheck().then(process.exit);` in your healthcheck.js
 * file (or whatever you invoke via `HEALTHCHECK` docker instruction).
 * 
 * @param staleInterval The number of milliseconds the heartbeat value is allowed to remain unchanged before reporting the container as unhealthy. 
 * @returns Process exit code used to signal the health of the container.
 */
export async function healthcheck(staleInterval = 10000): Promise<number> {
    // Get the current and last-seen heartbeats
    const [current, lastSeen] = await Promise.all([
        getCurrentHeartbeat(),
        getLastSeenHeartbeat(),
    ]);

    // Healthy if we haven't seen any heartbeats yet, or the heartbeat changed
    if (lastSeen == null || current !== lastSeen.heartbeat) {
        await setLastSeenHeartbeat(current);
        return 0;
    }

    // Healthy if the heartbeat has been stale for at most the specified interval
    if (Date.now() - lastSeen.timestamp < staleInterval) {
        return 0;
    }

    // Otherwise, unhealthy
    return 1;
}

async function setCurrentHeartbeat(): Promise<void> {
    await fs.mkdir(dataPath, {
        recursive: true,
    });
    await fs.writeFile(
        heartbeatFilePath,
        JSON.stringify(<HeartbeatInfo>{
            heartbeat: uuidv4(),
        }),
    );
}

async function getCurrentHeartbeat(): Promise<string> {
    const fileContent = await readFileContent(heartbeatFilePath);

    if (fileContent == null) {
        return 'NONE';
    } else {
        const info: HeartbeatInfo = JSON.parse(fileContent);
        return info.heartbeat;
    }
}

async function getLastSeenHeartbeat(): Promise<HeartbeatCheck | undefined> {
    const fileContent = await readFileContent(lastSeenFilePath);

    if (fileContent == null) {
        return undefined;
    } else {
        return JSON.parse(fileContent) as HeartbeatCheck;
    }
}

async function setLastSeenHeartbeat(heartbeat: string): Promise<void> {
    await fs.mkdir(dataPath, {
        recursive: true,
    });
    await fs.writeFile(
        lastSeenFilePath,
        JSON.stringify(<HeartbeatCheck>{
            heartbeat: heartbeat,
            timestamp: Date.now(),
        }),
    );
}

/** Get file contents. Returns `undefined` if the file doesn't exist. */
async function readFileContent(filePath: string): Promise<string | undefined> {
    try {
        const fileContent = await fs.readFile(filePath);
        return fileContent.toString('utf8');
    } catch (error) {
        if (error.code === 'ENOENT') {
            return undefined;
        } else {
            throw error;
        }
    }
}